---
title: "POST /auth/privy/verify"
api: "POST https://api.onekey.so/api/v1/auth/privy/verify"
description: "Verify a Privy Web3 wallet signature and generate an authenticated session"
---

## Overview

Verify a Privy-generated signature from a Web3 wallet and create an authenticated session. This endpoint integrates with Privy's authentication infrastructure to enable seamless Web3 user onboarding.

<Note>
This endpoint requires Privy to be configured in your OneKey dashboard. Users must first authenticate with Privy on the client side.
</Note>

## Request

### Headers

```http
Content-Type: application/json
Accept: application/json
```

### Body Parameters

<ParamField body="privyToken" type="string" required>
  The Privy authentication token from the client
</ParamField>

<ParamField body="walletAddress" type="string" required>
  The connected wallet address
</ParamField>

<ParamField body="signature" type="string" required>
  The signature generated by the wallet
</ParamField>

<ParamField body="message" type="string" required>
  The original message that was signed
</ParamField>

<ParamField body="chainId" type="number" required>
  The blockchain network ID (1 for Ethereum mainnet, 137 for Polygon, etc.)
</ParamField>

<ParamField body="nonce" type="string">
  Optional nonce for replay protection
</ParamField>

<ParamField body="expiresIn" type="string" default="24h">
  Token expiration time for the generated session
</ParamField>

### Example Request

<CodeGroup>

```bash cURL
curl -X POST https://api.onekey.so/api/v1/auth/privy/verify \
  -H "Content-Type: application/json" \
  -d '{
    "privyToken": "privy_token_...",
    "walletAddress": "0x742d35Cc6C88BfD5b3DC4B8A76C04E2dCB3cCF6D",
    "signature": "0x1b2c3d4e5f...",
    "message": "Sign in to OneKey with your wallet. Timestamp: 1640995200",
    "chainId": 1,
    "nonce": "abc123def456"
  }'
```

```javascript JavaScript
import { usePrivy } from '@privy-io/react-auth';

const PrivyAuth = () => {
  const { login, authenticated, user } = usePrivy();
  
  const authenticateWithOneKey = async () => {
    if (!authenticated) {
      await login();
    }
    
    // Get Privy token
    const privyToken = await user.getAccessToken();
    
    // Create signature message
    const message = `Sign in to OneKey with your wallet. Timestamp: ${Date.now()}`;
    
    // Request signature from user's wallet
    const signature = await window.ethereum.request({
      method: 'personal_sign',
      params: [message, user.wallet.address],
    });
    
    // Verify with OneKey
    const response = await fetch('/api/v1/auth/privy/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        privyToken,
        walletAddress: user.wallet.address,
        signature,
        message,
        chainId: user.wallet.chainId,
        nonce: crypto.randomUUID()
      })
    });
    
    const data = await response.json();
    return data.data.accessToken;
  };
  
  return (
    <button onClick={authenticateWithOneKey}>
      Connect Wallet & Authenticate
    </button>
  );
};
```

```python Python
import requests
from eth_account.messages import encode_defunct
from eth_account import Account

def verify_privy_signature(privy_token, wallet_address, private_key, message):
    # Sign the message (this would typically be done client-side)
    message_hash = encode_defunct(text=message)
    signature = Account.sign_message(message_hash, private_key).signature.hex()
    
    response = requests.post(
        'https://api.onekey.so/api/v1/auth/privy/verify',
        headers={'Content-Type': 'application/json'},
        json={
            'privyToken': privy_token,
            'walletAddress': wallet_address,
            'signature': signature,
            'message': message,
            'chainId': 1,
            'nonce': 'unique_nonce_123'
        }
    )
    
    data = response.json()
    return data['data']['accessToken']
```

</CodeGroup>

## Response

<ResponseField name="success" type="boolean">
  Whether the verification was successful
</ResponseField>

<ResponseField name="data" type="object">
  <Expandable title="properties">
    <ResponseField name="accessToken" type="string">
      JWT access token for API authentication
    </ResponseField>
    
    <ResponseField name="tokenType" type="string">
      Token type (always "Bearer")
    </ResponseField>
    
    <ResponseField name="expiresIn" type="number">
      Token expiration time in seconds
    </ResponseField>
    
    <ResponseField name="expiresAt" type="string">
      Token expiration timestamp (ISO 8601)
    </ResponseField>
    
    <ResponseField name="user" type="object">
      <Expandable title="User information">
        <ResponseField name="id" type="string">
          OneKey user identifier
        </ResponseField>
        
        <ResponseField name="walletAddress" type="string">
          Verified wallet address
        </ResponseField>
        
        <ResponseField name="privyId" type="string">
          Privy user identifier
        </ResponseField>
        
        <ResponseField name="chainId" type="number">
          Connected blockchain network
        </ResponseField>
        
        <ResponseField name="walletType" type="string">
          Wallet provider (MetaMask, WalletConnect, etc.)
        </ResponseField>
        
        <ResponseField name="isNewUser" type="boolean">
          Whether this is the user's first authentication
        </ResponseField>
      </Expandable>
    </ResponseField>
    
    <ResponseField name="permissions" type="array">
      Granted permissions for Web3 users
    </ResponseField>
    
    <ResponseField name="session" type="object">
      <Expandable title="Session details">
        <ResponseField name="id" type="string">
          Session identifier
        </ResponseField>
        
        <ResponseField name="createdAt" type="string">
          Session creation timestamp
        </ResponseField>
        
        <ResponseField name="lastActivity" type="string">
          Last activity timestamp
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>

### Example Response

```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 86400,
    "expiresAt": "2024-01-16T10:30:45.123Z",
    "user": {
      "id": "user_1a2b3c4d5e",
      "walletAddress": "0x742d35Cc6C88BfD5b3DC4B8A76C04E2dCB3cCF6D",
      "privyId": "did:privy:clzmk8ej70...",
      "chainId": 1,
      "walletType": "metamask",
      "isNewUser": false
    },
    "permissions": [
      "kyc:read",
      "kyc:write",
      "attestations:read",
      "encryption:use"
    ],
    "session": {
      "id": "session_9f8e7d6c5b",
      "createdAt": "2024-01-15T10:30:45.123Z",
      "lastActivity": "2024-01-15T10:30:45.123Z"
    }
  },
  "requestId": "req_123456789",
  "timestamp": "2024-01-15T10:30:45.123Z"
}
```

## Web3 Integration

### React with Privy

```jsx
import { PrivyProvider, usePrivy } from '@privy-io/react-auth';
import { useState } from 'react';

function App() {
  return (
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        appearance: {
          theme: 'light',
          accentColor: '#676FFF',
        },
        embeddedWallets: {
          createOnLogin: 'users-without-wallets'
        }
      }}
    >
      <OneKeyAuth />
    </PrivyProvider>
  );
}

function OneKeyAuth() {
  const { ready, authenticated, user, login, logout } = usePrivy();
  const [oneKeyToken, setOneKeyToken] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const authenticateWithOneKey = async () => {
    setLoading(true);
    try {
      // Get Privy access token
      const privyToken = await user.getAccessToken();
      
      // Create signature message
      const timestamp = Date.now();
      const message = `Welcome to OneKey!\n\nPlease sign this message to authenticate.\n\nTimestamp: ${timestamp}`;
      
      // Request signature
      const signature = await user.wallet.sign(message);
      
      // Verify with OneKey API
      const response = await fetch('/api/v1/auth/privy/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          privyToken,
          walletAddress: user.wallet.address,
          signature,
          message,
          chainId: user.wallet.chainId,
          nonce: crypto.randomUUID(),
          expiresIn: '24h'
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        setOneKeyToken(data.data.accessToken);
        // Store token securely
        localStorage.setItem('onekey_token', data.data.accessToken);
      } else {
        throw new Error(data.error.message);
      }
    } catch (error) {
      console.error('OneKey authentication failed:', error);
      alert('Authentication failed: ' + error.message);
    } finally {
      setLoading(false);
    }
  };
  
  if (!ready) return <div>Loading...</div>;
  
  if (!authenticated) {
    return (
      <div>
        <h1>Connect Your Wallet</h1>
        <button onClick={login}>Connect Wallet</button>
      </div>
    );
  }
  
  return (
    <div>
      <h1>Welcome, {user.wallet.address}</h1>
      <p>Network: {user.wallet.chainId}</p>
      
      {!oneKeyToken ? (
        <button onClick={authenticateWithOneKey} disabled={loading}>
          {loading ? 'Authenticating...' : 'Authenticate with OneKey'}
        </button>
      ) : (
        <div>
          <p>âœ… Authenticated with OneKey</p>
          <button onClick={() => {
            setOneKeyToken(null);
            localStorage.removeItem('onekey_token');
          }}>
            Disconnect OneKey
          </button>
        </div>
      )}
      
      <button onClick={logout}>Disconnect Wallet</button>
    </div>
  );
}
```

### Wagmi Integration

```jsx
import { useAccount, useSignMessage } from 'wagmi';
import { usePrivy } from '@privy-io/react-auth';

function WagmiOneKeyAuth() {
  const { address, isConnected, chainId } = useAccount();
  const { signMessage } = useSignMessage();
  const { user, getAccessToken } = usePrivy();
  
  const authenticateWithOneKey = async () => {
    if (!isConnected) {
      throw new Error('Wallet not connected');
    }
    
    try {
      // Get Privy token
      const privyToken = await getAccessToken();
      
      // Create and sign message
      const message = `Authenticate with OneKey\nAddress: ${address}\nTimestamp: ${Date.now()}`;
      
      const signature = await signMessage({ message });
      
      // Verify with OneKey
      const response = await fetch('/api/v1/auth/privy/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          privyToken,
          walletAddress: address,
          signature,
          message,
          chainId,
          nonce: crypto.randomUUID()
        })
      });
      
      const data = await response.json();
      return data.data.accessToken;
      
    } catch (error) {
      console.error('Authentication failed:', error);
      throw error;
    }
  };
  
  return (
    <button onClick={authenticateWithOneKey}>
      Authenticate with OneKey
    </button>
  );
}
```

## Error Responses

<ResponseExample>

```json 400 Invalid Signature
{
  "success": false,
  "error": {
    "code": "AUTH_INVALID_SIGNATURE",
    "message": "Signature verification failed",
    "details": {
      "reason": "Signature does not match the message and wallet address",
      "expectedSigner": "0x742d35Cc6C88BfD5b3DC4B8A76C04E2dCB3cCF6D",
      "recoveredSigner": "0x123456789..."
    }
  },
  "requestId": "req_123456789",
  "timestamp": "2024-01-15T10:30:45.123Z"
}
```

```json 401 Invalid Privy Token
{
  "success": false,
  "error": {
    "code": "AUTH_PRIVY_TOKEN_INVALID",
    "message": "Privy token validation failed",
    "details": {
      "reason": "Token expired or malformed",
      "action": "Re-authenticate with Privy"
    }
  },
  "requestId": "req_123456789",
  "timestamp": "2024-01-15T10:30:45.123Z"
}
```

```json 400 Unsupported Chain
{
  "success": false,
  "error": {
    "code": "AUTH_UNSUPPORTED_CHAIN",
    "message": "Blockchain network not supported",
    "details": {
      "providedChainId": 56,
      "supportedChains": [1, 137, 10, 42161]
    }
  },
  "requestId": "req_123456789",
  "timestamp": "2024-01-15T10:30:45.123Z"
}
```

</ResponseExample>

## Security Features

<AccordionGroup>
  <Accordion title="Signature Verification">
    **Cryptographic signature validation**
    
    - ECDSA signature verification
    - Message hash validation
    - Replay attack protection via nonces
    - Address recovery verification
    
    ```javascript
    // Client-side signature generation
    const createSignatureMessage = (address, timestamp, nonce) => {
      return `OneKey Authentication
    
    Wallet: ${address}
    Timestamp: ${timestamp}
    Nonce: ${nonce}
    
    I authorize OneKey to access my account with this signature.`;
    };
    ```
  </Accordion>
  
  <Accordion title="Privy Integration">
    **Enhanced Web3 authentication**
    
    - Privy token validation
    - Cross-wallet compatibility
    - Social login support
    - Progressive onboarding
    
    ```javascript
    // Privy configuration for OneKey
    const privyConfig = {
      embeddedWallets: {
        createOnLogin: 'users-without-wallets',
        noPromptOnSignature: false
      },
      loginMethods: ['wallet', 'email', 'google'],
      appearance: {
        theme: 'light',
        accentColor: '#4F46E5'
      }
    };
    ```
  </Accordion>
  
  <Accordion title="Session Management">
    **Secure session handling**
    
    - JWT token generation
    - Session tracking
    - Activity monitoring
    - Automatic logout on suspicious activity
    
    ```javascript
    // Session monitoring
    const monitorSession = (token) => {
      const payload = JSON.parse(atob(token.split('.')[1]));
      
      // Check for session anomalies
      if (payload.chainId !== currentChainId) {
        console.warn('Chain mismatch detected');
        // Trigger re-authentication
      }
      
      // Monitor token expiration
      const expiresAt = new Date(payload.exp * 1000);
      const refreshThreshold = new Date(Date.now() + 5 * 60 * 1000);
      
      if (expiresAt <= refreshThreshold) {
        // Trigger token refresh
        refreshToken(token);
      }
    };
    ```
  </Accordion>
</AccordionGroup>

## Rate Limiting

This endpoint is rate limited to **20 requests per minute** per IP address.

<Warning>
Implement proper error handling for rate limits to provide a smooth user experience.
</Warning>

## Best Practices

### Client-Side Implementation

```javascript
class OneKeyWeb3Auth {
  constructor(privyConfig) {
    this.privy = new PrivyClient(privyConfig);
    this.oneKeyToken = null;
    this.refreshTimer = null;
  }
  
  async authenticate() {
    try {
      // Step 1: Authenticate with Privy
      const privyUser = await this.privy.login();
      
      // Step 2: Get Privy access token
      const privyToken = await privyUser.getAccessToken();
      
      // Step 3: Create signature
      const nonce = crypto.randomUUID();
      const timestamp = Date.now();
      const message = this.createMessage(privyUser.wallet.address, timestamp, nonce);
      
      const signature = await privyUser.wallet.sign(message);
      
      // Step 4: Verify with OneKey
      const oneKeyAuth = await this.verifyWithOneKey({
        privyToken,
        walletAddress: privyUser.wallet.address,
        signature,
        message,
        chainId: privyUser.wallet.chainId,
        nonce
      });
      
      this.oneKeyToken = oneKeyAuth.accessToken;
      this.setupTokenRefresh(oneKeyAuth.expiresIn);
      
      return oneKeyAuth;
      
    } catch (error) {
      console.error('Authentication failed:', error);
      throw error;
    }
  }
  
  createMessage(address, timestamp, nonce) {
    return `OneKey Authentication Request

Wallet Address: ${address}
Timestamp: ${timestamp}
Nonce: ${nonce}

By signing this message, I authorize OneKey to access my account.

This signature will not trigger any blockchain transactions.`;
  }
  
  async verifyWithOneKey(authData) {
    const response = await fetch('/api/v1/auth/privy/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(authData)
    });
    
    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error.message);
    }
    
    return data.data;
  }
  
  setupTokenRefresh(expiresIn) {
    // Refresh 5 minutes before expiration
    const refreshTime = (expiresIn - 300) * 1000;
    
    this.refreshTimer = setTimeout(async () => {
      try {
        await this.refreshToken();
      } catch (error) {
        console.error('Token refresh failed:', error);
        // Fall back to full re-authentication
        await this.authenticate();
      }
    }, refreshTime);
  }
  
  async makeAuthenticatedRequest(url, options = {}) {
    if (!this.oneKeyToken) {
      await this.authenticate();
    }
    
    return fetch(url, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.oneKeyToken}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="KYC Sessions" icon="id-card" href="/api-reference/kyc/create-session">
    Start identity verification for authenticated users
  </Card>
  <Card title="Encryption" icon="lock" href="/api-reference/encryption/encrypt">
    Encrypt sensitive data before storage
  </Card>
  <Card title="Attestations" icon="shield" href="/api-reference/attestations/create">
    Create blockchain proofs for verified identities
  </Card>
  <Card title="Web3 Guide" icon="wallet" href="/guides/web3-auth">
    Complete Web3 authentication integration guide
  </Card>
</CardGroup> 